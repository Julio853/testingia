# -*- coding: utf-8 -*-
"""saveia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q_hjwXB5_hjnMHmFrvIOrmf6LnzM5UfE
"""

from keras.models import load_model
from tensorflow.keras import layers, models
import tensorflow as tf

from tensorflow import keras
from tensorflow.keras.utils import to_categorical

import numpy as np

from IPython.display import clear_output
import cv2

from sklearn.model_selection import train_test_split
import os

from sklearn.metrics import confusion_matrix

def cargar_imagenes_de_folder(folder):
  images = []
  for filename in os.listdir(folder):
    img = cv2.imread(os.path.join(folder,filename))
    if img is not None:
      img = cv2.resize(img,(224,224))
      img = np.asarray(img)
      img = (img.astype(np.float32) / 127.0) - 1
      images.append(img)
  return images

images = []
labels = []
class_names = ['insana','sana']

for label in class_names:
  images_tmp = cargar_imagenes_de_folder("imagenes/" + label)
  labels_tmp = [label] * len(images_tmp)

  images.extend(images_tmp)
  labels.extend(labels_tmp)

images = np.array(images)

def class_encoding(labels):
  a,b = np.unique(labels, return_inverse = True)
  return b,a

labels, class_names = class_encoding(labels)

print(labels)

train_images, test_images, train_labels, test_labels = train_test_split(
   images,
   labels,
   test_size = 0.3,
   random_state = 123
)
train_labels = to_categorical(train_labels)
test_labels = to_categorical(test_labels)

model = models.Sequential()

model.add(layers.Conv2D(32,(3,3), activation = 'relu', input_shape=(224,224,3)))
model.add(layers.MaxPool2D((2,2)))

model.add(layers.Conv2D(64,(3,3), activation = 'relu'))
model.add(layers.MaxPool2D((2,2)))

model.add(layers.Flatten())
model.add(layers.Dense(64,activation='relu'))
model.add(layers.Dense(2,activation='softmax'))

model.summary()

model.compile(optimizer=keras.optimizers.Adam(learning_rate=0.001),
              loss=tf.keras.losses.categorical_crossentropy,
              metrics=['accuracy'])

history = model.fit(train_images,
                    train_labels,
                    epochs=10,
                    batch_size=16,
                    validation_data=(test_images,test_labels))

y_pred = model.predict(test_images)
y_class = np.argmax(y_pred,axis=1)

print(y_class)

model.save('modelo.h5')

# Cargar modelo de machine learning ya entrenado
model_cargado = load_model('modelo.h5')

# Cargar una imagen (la que se puede obtener por una cámara)

ruta_imagen_prueba = "prueba/4.jpg"

img_prueba = cv2.imread(ruta_imagen_prueba)

# Esto sólo en Colab
from google.colab.patches import cv2_imshow
cv2_imshow(img_prueba)

# Esto si se usa en otras plataformas (quitar el comentario para ejecutar)
# cv2.imshow(img_prueba)

# Realiza preprocesamiento
img_prueba = cv2.resize(img_prueba,(224,224))
img_prueba = np.asarray(img_prueba)
img_prueba = (img_prueba.astype(np.float32) / 127.0) - 1

imagen_prueba = []
imagen_prueba.append(img_prueba)
y_pred_prueba = model_cargado.predict(np.array(imagen_prueba))
y_class_prueba = np.argmax(y_pred_prueba,axis=1)

print(class_names[y_class_prueba])